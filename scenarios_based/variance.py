from gurobipy import GurobiError

import numpy as np
from matplotlib import pyplot as plt

import pickle
from data import figsize
from entities import PortfolioGroup
from markowitz import Markowitz
from scenarios_based.models import *
from scenarios import generateGaussianScenarios


def WeightsStdErr(model, N=100, M=100):
    """
    Computes the standard error of the model: generates M times the model with N scenarios, and returns the MAX of the
    standard errors of the weights of the output portfolios.
    :type model: PortfolioOptimizer
    :type M:        int - Number of samples
    :type N:        int - Sample size
    """
    objvals = []
    s, p = generateGaussianScenarios(N)
    m = model(s, p).update()
    for i in range(M):
        s, p = generateGaussianScenarios(N)
        m.reconfigure(s, p).optimize()
        try:
            objvals.append(m.objval)
        except GurobiError:
            pass
    # Recall: standard error = standard deviation / number of samples. It represents better the variability, because if
    # we increase the number of samples, the standard deviation may increase only because of the increase of the number
    # of samples, contrary to the standard error.
    # std_errors = np.std(portfolios, axis=0) / len(portfolios)
    # We return the Euclidian Norm of these standard errors. We could have use the mean, but it does not focus enough
    # on the big standard deviations, and we could have taken the max, but it is very unstable.
    return np.std(objvals)


def PlotVarWeights(N, M, model=SemiMAD):
    """Plots on the same chart M different output portfolios of the same model computed over N scenarios."""
    ports = []
    s, p = generateGaussianScenarios(N)
    m = model(s, p, Wmin=0.05).update()
    for i in range(M):
        s, p = generateGaussianScenarios(N)
        m.modelName = 'Sample {}'.format(i + 1)
        ports.append(m.reconfigure(s, p).optimize().getPortfolio())
    PortfolioGroup(ports).plot()
    plt.show()


def TestVol():
    """Compare the volatility of the portfolios generated by the different measures."""
    models = [Markowitz, MAD, SemiMAD, GMD, Minimax]
    rows = []
    s, p = generateGaussianScenarios(100)
    for model in models:
        model(s, p).optimize().getPortfolio().Vol()


def PlotStdErr(M=100, N=range(100, 1000, 100), model=SemiMAD, save=False, reload=False):

    stderrors = {}
    file_name = "pickle/stderr/{:s}_M{:d}.p".format(model.__name__, M)

    if reload:
        try:
            memory = pickle.load(open(file_name, 'rb'))
        except IOError:
            memory = {}
    else:
        memory = {}

    for n in N:
        print(n)
        if (M, n) in memory:
            stderrors[M, n] = memory[M, n]
        else:
            stderrors[M, n] = WeightsStdErr(model, N=n, M=M)
        if save:
            pickle.dump(stderrors, open(file_name, "wb"))
    plt.figure(figsize=figsize)
    plt.plot(N, stderrors.values())
    plt.show()


def PltStdErr(Model):
    x = range(10, 100, 10) + range(100, 1000, 100) + range(1000, 10000, 1000) + range(10000, 20001, 5000)
    maxes = []
    for N in x:
        print(N)
        m = Model(*generateGaussianScenarios(N)).update()
        maxes.append(np.array([m.reconfigure(*generateGaussianScenarios(N)).optimize().getPortfolio() for j in range(10)]).std(axis=0).max())
    with open('pickle/stderr/{:s}_20000.p'.format(Model.__name__), 'wb') as file:
        pickle.dump(maxes, file)
    return maxes

if __name__ == '__main__':
    PlotStdErr(200, range(500, 1501, 500), SemiMAD, save=True, reload=False)
